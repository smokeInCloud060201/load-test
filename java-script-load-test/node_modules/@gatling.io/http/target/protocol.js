"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapHttpProtocolBuilder = void 0;
const core_1 = require("@gatling.io/core");
const wrapHttpProtocolBuilder = (_underlying) => ({
    _underlying,
    baseUrl: (url) => (0, exports.wrapHttpProtocolBuilder)(_underlying.baseUrl(url)),
    baseUrls: (...urls) => (0, exports.wrapHttpProtocolBuilder)(_underlying.baseUrls(...urls)),
    warmUp: (url) => (0, exports.wrapHttpProtocolBuilder)(_underlying.warmUp(url)),
    disableWarmUp: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.disableWarmUp()),
    // Engine part
    shareConnections: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.shareConnections()),
    localAddress: (address) => (0, exports.wrapHttpProtocolBuilder)(_underlying.localAddress(address)),
    localAddresses: (...addresses) => (0, exports.wrapHttpProtocolBuilder)(_underlying.localAddresses(...addresses)),
    useAllLocalAddresses: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.useAllLocalAddresses()),
    useAllLocalAddressesMatching: (...patterns) => (0, exports.wrapHttpProtocolBuilder)(_underlying.useAllLocalAddressesMatching(...patterns)),
    maxConnectionsPerHost: (max) => (0, exports.wrapHttpProtocolBuilder)(_underlying.maxConnectionsPerHost(max)),
    // TODO perUserKeyManagerFactory
    // Request part
    disableAutoOrigin: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.disableAutoOrigin()),
    disableAutoReferer: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.disableAutoReferer()),
    disableCaching: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.disableCaching()),
    header: (name, value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.header(name, (0, core_1.underlyingSessionTo)(value))
        : _underlying.header(name, value)),
    headers: (headers) => (0, exports.wrapHttpProtocolBuilder)(_underlying.headers((0, core_1.asJava)(headers))),
    acceptHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.acceptHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.acceptHeader(value)),
    acceptCharsetHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.acceptCharsetHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.acceptCharsetHeader(value)),
    acceptEncodingHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.acceptEncodingHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.acceptEncodingHeader(value)),
    acceptLanguageHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.acceptLanguageHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.acceptLanguageHeader(value)),
    authorizationHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.authorizationHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.authorizationHeader(value)),
    connectionHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.connectionHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.connectionHeader(value)),
    contentTypeHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.contentTypeHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.contentTypeHeader(value)),
    doNotTrackHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.doNotTrackHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.doNotTrackHeader(value)),
    originHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.originHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.originHeader(value)),
    userAgentHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.userAgentHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.userAgentHeader(value)),
    upgradeInsecureRequestsHeader: (value) => (0, exports.wrapHttpProtocolBuilder)(typeof value === "function"
        ? _underlying.upgradeInsecureRequestsHeader((0, core_1.underlyingSessionTo)(value))
        : _underlying.upgradeInsecureRequestsHeader(value)),
    basicAuth: (username, password) => (0, exports.wrapHttpProtocolBuilder)(typeof username === "function"
        ? typeof password === "function"
            ? _underlying.basicAuth((0, core_1.underlyingSessionTo)(username), (0, core_1.underlyingSessionTo)(password))
            : _underlying.basicAuth((0, core_1.underlyingSessionTo)(username), password)
        : typeof password === "function"
            ? _underlying.basicAuth(username, (0, core_1.underlyingSessionTo)(password))
            : _underlying.basicAuth(username, password)),
    digestAuth: (username, password) => (0, exports.wrapHttpProtocolBuilder)(typeof username === "function"
        ? typeof password === "function"
            ? _underlying.digestAuth((0, core_1.underlyingSessionTo)(username), (0, core_1.underlyingSessionTo)(password))
            : _underlying.digestAuth((0, core_1.underlyingSessionTo)(username), password)
        : typeof password === "function"
            ? _underlying.digestAuth(username, (0, core_1.underlyingSessionTo)(password))
            : _underlying.digestAuth(username, password)),
    silentResources: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.silentResources()),
    silentUri: (pattern) => (0, exports.wrapHttpProtocolBuilder)(_underlying.silentUri(pattern)),
    disableUrlEncoding: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.disableUrlEncoding()),
    //sign: (calculator: (request: Request, session: Session) => Request): HttpProtocolBuilder =>
    //  wrapHttpProtocolBuilder(_underlying.sign(wrapBiCallback(underlyingRequestTransform(calculator)))),
    signWithOAuth1: (consumerKey, clientSharedSecret, token, tokenSecret, useAuthorizationHeader) => (0, exports.wrapHttpProtocolBuilder)(typeof consumerKey === "function" &&
        typeof clientSharedSecret === "function" &&
        typeof token === "function" &&
        typeof tokenSecret === "function"
        ? typeof useAuthorizationHeader !== "undefined"
            ? _underlying.signWithOAuth1((0, core_1.underlyingSessionTo)(consumerKey), (0, core_1.underlyingSessionTo)(clientSharedSecret), (0, core_1.underlyingSessionTo)(token), (0, core_1.underlyingSessionTo)(tokenSecret), useAuthorizationHeader)
            : _underlying.signWithOAuth1((0, core_1.underlyingSessionTo)(consumerKey), (0, core_1.underlyingSessionTo)(clientSharedSecret), (0, core_1.underlyingSessionTo)(token), (0, core_1.underlyingSessionTo)(tokenSecret))
        : typeof useAuthorizationHeader !== "undefined"
            ? _underlying.signWithOAuth1(consumerKey, clientSharedSecret, token, tokenSecret, useAuthorizationHeader)
            : _underlying.signWithOAuth1(consumerKey, clientSharedSecret, token, tokenSecret)),
    enableHttp2: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.enableHttp2()),
    http2PriorKnowledge: (remotes) => (0, exports.wrapHttpProtocolBuilder)(_underlying.http2PriorKnowledge(remotes)),
    // Response part
    disableFollowRedirect: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.disableFollowRedirect()),
    maxRedirects: (max) => (0, exports.wrapHttpProtocolBuilder)(_underlying.maxRedirects(max)),
    strict302Handling: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.strict302Handling()),
    //transformResponse: (f: (response: Response, session: Session) => Response): HttpProtocolBuilder =>
    //  wrapHttpProtocolBuilder(_underlying.transformResponse(wrapBiCallback(underlyingResponseTransform(f)))),
    check: (...checks) => (0, exports.wrapHttpProtocolBuilder)(_underlying.check(checks.map((c) => c._underlying))),
    checkIf: (condition) => (0, core_1.wrapCondition)(typeof condition === "string"
        ? _underlying.checkIf(condition)
        : _underlying.checkIf((0, core_1.underlyingSessionTo)(condition)), exports.wrapHttpProtocolBuilder),
    inferHtmlResources: (arg0, arg1) => (0, exports.wrapHttpProtocolBuilder)(arg0 !== undefined
        ? arg1 !== undefined
            ? _underlying.inferHtmlResources(arg0._underlying, arg1._underlying)
            : _underlying.inferHtmlResources(arg0._underlying)
        : _underlying.inferHtmlResources()),
    nameInferredHtmlResourcesAfterUrlTail: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.nameInferredHtmlResourcesAfterUrlTail()),
    nameInferredHtmlResourcesAfterAbsoluteUrl: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.nameInferredHtmlResourcesAfterAbsoluteUrl()),
    nameInferredHtmlResourcesAfterRelativeUrl: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.nameInferredHtmlResourcesAfterRelativeUrl()),
    nameInferredHtmlResourcesAfterPath: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.nameInferredHtmlResourcesAfterPath()),
    nameInferredHtmlResourcesAfterLastPathElement: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.nameInferredHtmlResourcesAfterLastPathElement()),
    // Proxy part
    proxy: (proxy) => (0, exports.wrapHttpProtocolBuilder)(_underlying.proxy(proxy._underlying)),
    noProxyFor: (...hosts) => (0, exports.wrapHttpProtocolBuilder)(_underlying.noProxyFor(...hosts)),
    proxyProtocolSourceIpV4Address: (address) => (0, exports.wrapHttpProtocolBuilder)(typeof address === "string"
        ? _underlying.proxyProtocolSourceIpV4Address(address)
        : _underlying.proxyProtocolSourceIpV4Address((0, core_1.underlyingSessionTo)(address))),
    proxyProtocolSourceIpV6Address: (address) => (0, exports.wrapHttpProtocolBuilder)(typeof address === "string"
        ? _underlying.proxyProtocolSourceIpV6Address(address)
        : _underlying.proxyProtocolSourceIpV6Address((0, core_1.underlyingSessionTo)(address))),
    // DNS part
    asyncNameResolution: (...dnsServers) => (0, exports.wrapHttpProtocolBuilder)(_underlying.asyncNameResolution(...dnsServers)),
    hostNameAliases: (aliases) => (0, exports.wrapHttpProtocolBuilder)(_underlying.hostNameAliases(aliases)),
    perUserNameResolution: () => (0, exports.wrapHttpProtocolBuilder)(_underlying.perUserNameResolution())
});
exports.wrapHttpProtocolBuilder = wrapHttpProtocolBuilder;
