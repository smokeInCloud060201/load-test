"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.http = exports.underlyingResponseTransform = exports.underlyingRequestTransform = void 0;
const core_1 = require("@gatling.io/core");
const core_2 = require("@gatling.io/core");
const jvm_types_1 = require("@gatling.io/jvm-types");
const protocol_1 = require("./protocol");
const request_1 = require("./request");
const response_1 = require("./response");
__exportStar(require("./bodyPart"), exports);
__exportStar(require("./checks"), exports);
__exportStar(require("./cookies"), exports);
__exportStar(require("./feeders"), exports);
__exportStar(require("./headers"), exports);
__exportStar(require("./method"), exports);
__exportStar(require("./polling"), exports);
__exportStar(require("./protocol"), exports);
__exportStar(require("./proxy"), exports);
__exportStar(require("./request"), exports);
__exportStar(require("./response"), exports);
const underlyingRequestTransform = (f) => (jvmRequest, jvmSession) => f((0, request_1.wrapRequest)(jvmRequest), (0, core_1.wrapSession)(jvmSession))._underlying;
exports.underlyingRequestTransform = underlyingRequestTransform;
const underlyingResponseTransform = (f) => (jvmResponse, jvmSession) => f((0, response_1.wrapResponse)(jvmResponse), (0, core_1.wrapSession)(jvmSession))._underlying;
exports.underlyingResponseTransform = underlyingResponseTransform;
const httpProtocolBuilder = (0, protocol_1.wrapHttpProtocolBuilder)(
// HttpDsl.http doesn't get properly generated by java2ts because of conflicts with methods of the same name
Java.type("io.gatling.javaapi.http.HttpDsl").http);
const wrapHttp = (jvmHttp) => ({
    get: (url) => (0, request_1.wrapHttpRequestActionBuilder)(typeof url === "function" ? jvmHttp.get((0, core_2.underlyingSessionTo)(url)) : jvmHttp.get(url)),
    put: (url) => (0, request_1.wrapHttpRequestActionBuilder)(typeof url === "function" ? jvmHttp.put((0, core_2.underlyingSessionTo)(url)) : jvmHttp.put(url)),
    post: (url) => (0, request_1.wrapHttpRequestActionBuilder)(typeof url === "function" ? jvmHttp.post((0, core_2.underlyingSessionTo)(url)) : jvmHttp.post(url)),
    patch: (url) => (0, request_1.wrapHttpRequestActionBuilder)(typeof url === "function" ? jvmHttp.patch((0, core_2.underlyingSessionTo)(url)) : jvmHttp.patch(url)),
    head: (url) => (0, request_1.wrapHttpRequestActionBuilder)(typeof url === "function" ? jvmHttp.head((0, core_2.underlyingSessionTo)(url)) : jvmHttp.head(url)),
    delete: (url) => (0, request_1.wrapHttpRequestActionBuilder)(typeof url === "function" ? jvmHttp.delete((0, core_2.underlyingSessionTo)(url)) : jvmHttp.delete(url)),
    options: (url) => (0, request_1.wrapHttpRequestActionBuilder)(typeof url === "function" ? jvmHttp.options((0, core_2.underlyingSessionTo)(url)) : jvmHttp.options(url)),
    httpRequest: (method, url) => (0, request_1.wrapHttpRequestActionBuilder)(typeof url === "function"
        ? jvmHttp.httpRequest(method, (0, core_2.underlyingSessionTo)(url))
        : jvmHttp.httpRequest(method, url))
});
const httpApply = (name) => {
    // Handle overloading
    const jvmHttp = typeof name === "string" ? jvm_types_1.HttpDsl.http(name) : jvm_types_1.HttpDsl.http((0, core_2.underlyingSessionTo)(name));
    return wrapHttp(jvmHttp);
};
exports.http = Object.assign(httpApply, httpProtocolBuilder);
