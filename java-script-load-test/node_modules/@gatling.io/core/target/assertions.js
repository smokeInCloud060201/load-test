"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.details = exports.forAll = exports.global = void 0;
const jvm_types_1 = require("@gatling.io/jvm-types");
/**
 * Bootstrap a new global assertion that targets stats aggregated on all requests
 *
 * @returns the next DSL step
 */
const global = () => wrapAssertionWithPath(jvm_types_1.CoreDsl.global());
exports.global = global;
/**
 * Bootstrap a new forAll assertion that targets stats on each individual request type
 *
 * @returns the next DSL step
 */
const forAll = () => wrapAssertionWithPath(jvm_types_1.CoreDsl.forAll());
exports.forAll = forAll;
/**
 * Bootstrap a new details assertion that targets stats on a specific request type
 *
 * @returns the next DSL step
 */
const details = (...parts) => wrapAssertionWithPath(jvm_types_1.CoreDsl.details(...parts));
exports.details = details;
const wrapAssertionWithPath = (_underlying) => ({
    responseTime: () => wrapAssertionWithPathAndTimeMetric(_underlying.responseTime()),
    allRequests: () => wrapAssertionWithPathAndCountMetric(_underlying.allRequests()),
    failedRequests: () => wrapAssertionWithPathAndCountMetric(_underlying.failedRequests()),
    successfulRequests: () => wrapAssertionWithPathAndCountMetric(_underlying.successfulRequests()),
    requestsPerSec: () => wrapAssertionWithPathAndTarget(_underlying.requestsPerSec())
});
const wrapAssertionWithPathAndTimeMetric = (_underlying) => ({
    min: () => wrapAssertionWithPathAndTarget(_underlying.min()),
    max: () => wrapAssertionWithPathAndTarget(_underlying.max()),
    mean: () => wrapAssertionWithPathAndTarget(_underlying.mean()),
    stdDev: () => wrapAssertionWithPathAndTarget(_underlying.stdDev()),
    percentile1: () => wrapAssertionWithPathAndTarget(_underlying.percentile1()),
    percentile2: () => wrapAssertionWithPathAndTarget(_underlying.percentile2()),
    percentile3: () => wrapAssertionWithPathAndTarget(_underlying.percentile3()),
    percentile4: () => wrapAssertionWithPathAndTarget(_underlying.percentile4()),
    percentile: (value) => wrapAssertionWithPathAndTarget(_underlying.percentile(value))
});
const wrapAssertionWithPathAndCountMetric = (_underlying) => ({
    count: () => wrapAssertionWithPathAndTarget(_underlying.count()),
    percent: () => wrapAssertionWithPathAndTarget(_underlying.percent())
});
const wrapAssertionWithPathAndTarget = (_underlying) => ({
    lt: (value) => wrapAssertion(_underlying.lt(value)),
    lte: (value) => wrapAssertion(_underlying.lte(value)),
    gt: (value) => wrapAssertion(_underlying.gt(value)),
    gte: (value) => wrapAssertion(_underlying.gte(value)),
    between: (min, max, inclusive) => wrapAssertion(inclusive !== undefined ? _underlying.between(min, max, inclusive) : _underlying.between(min, max)),
    around: (mean, plusOrMinus, inclusive) => wrapAssertion(inclusive !== undefined ? _underlying.around(mean, plusOrMinus, inclusive) : _underlying.around(mean, plusOrMinus)),
    deviatesAround: (mean, percentDeviation, inclusive) => wrapAssertion(inclusive !== undefined
        ? _underlying.deviatesAround(mean, percentDeviation, inclusive)
        : _underlying.deviatesAround(mean, percentDeviation)),
    is: (value) => wrapAssertion(_underlying.is(value)),
    in: (...values) => wrapAssertion(_underlying.in(values))
});
const wrapAssertion = (_underlying) => ({
    _underlying
});
