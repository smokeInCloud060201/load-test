import { Wrapper } from "./common";
import JvmAssertion = io.gatling.javaapi.core.Assertion;
/**
 * Bootstrap a new global assertion that targets stats aggregated on all requests
 *
 * @returns the next DSL step
 */
export declare const global: () => AssertionWithPath;
/**
 * Bootstrap a new forAll assertion that targets stats on each individual request type
 *
 * @returns the next DSL step
 */
export declare const forAll: () => AssertionWithPath;
/**
 * Bootstrap a new details assertion that targets stats on a specific request type
 *
 * @returns the next DSL step
 */
export declare const details: (...parts: string[]) => AssertionWithPath;
/**
 * Step 2 of the Assertion DSL (path defined). Immutable, so all methods return a new occurrence
 * and leave the original unmodified.
 */
export interface AssertionWithPath {
    /**
     * Specify the Assertion targets the response time metric
     *
     * @returns the next Assertion DSL step
     */
    responseTime(): AssertionWithPathAndTimeMetric;
    /**
     * Specify the Assertion targets the all requests count metric
     *
     * @returns the next Assertion DSL step
     */
    allRequests(): AssertionWithPathAndCountMetric;
    /**
     * Specify the Assertion targets the failed requests count metric
     *
     * @returns the next Assertion DSL step
     */
    failedRequests(): AssertionWithPathAndCountMetric;
    /**
     * Specify the Assertion targets the successful requests count metric
     *
     * @returns the next Assertion DSL step
     */
    successfulRequests(): AssertionWithPathAndCountMetric;
    /**
     * Specify the Assertion targets the requests/s metric
     *
     * @returns the next Assertion DSL step
     */
    requestsPerSec(): AssertionWithPathAndTarget;
}
/**
 * Step 3 of the Assertion DSL (path and time metric defined). Immutable, so all methods return a
 * new occurrence and leave the original unmodified.
 */
export interface AssertionWithPathAndTimeMetric {
    /**
     * Specify the Assertion targets the min value metric
     *
     * @returns the next Assertion DSL step (condition in the next step must be specified with integer values only)
     */
    min(): AssertionWithPathAndTarget;
    /**
     * Specify the Assertion targets the max value metric
     *
     * @returns the next Assertion DSL step (condition in the next step must be specified with integer values only)
     */
    max(): AssertionWithPathAndTarget;
    /**
     * Specify the Assertion targets the mean value metric
     *
     * @returns the next Assertion DSL step (condition in the next step must be specified with integer values only)
     */
    mean(): AssertionWithPathAndTarget;
    /**
     * Specify the Assertion targets the standard deviation metric
     *
     * @returns the next Assertion DSL step (condition in the next step must be specified with integer values only)
     */
    stdDev(): AssertionWithPathAndTarget;
    /**
     * Specify the Assertion targets the percentile1 metric, as defined in gatling.conf
     *
     * @returns the next Assertion DSL step (condition in the next step must be specified with integer values only)
     */
    percentile1(): AssertionWithPathAndTarget;
    /**
     * Specify the Assertion targets the percentile2 metric, as defined in gatling.conf
     *
     * @returns the next Assertion DSL step (condition in the next step must be specified with integer values only)
     */
    percentile2(): AssertionWithPathAndTarget;
    /**
     * Specify the Assertion targets the percentile3 metric, as defined in gatling.conf
     *
     * @returns the next Assertion DSL step
     */
    percentile3(): AssertionWithPathAndTarget;
    /**
     * Specify the Assertion targets the percentile4 metric, as defined in gatling.conf
     *
     * @returns the next Assertion DSL step (condition in the next step must be specified with integer values only)
     */
    percentile4(): AssertionWithPathAndTarget;
    /**
     * Specify the Assertion targets the given percentile metric
     *
     * @param value - the value of targeted percentile, between 0 and 100)
     * @returns the next Assertion DSL step (condition in the next step must be specified with integer values only)
     */
    percentile(value: number): AssertionWithPathAndTarget;
}
/**
 * Step 3 of the Assertion DSL (path and count metric defined). Immutable, so all methods return a
 * new occurrence and leave the original unmodified.
 */
export interface AssertionWithPathAndCountMetric {
    /**
     * Specify the Assertion targets the count metric
     *
     * @returns the next Assertion DSL step (condition in the next step must be specified with integer values only)
     */
    count(): AssertionWithPathAndTarget;
    /**
     * Specify the Assertion targets the percentage of total executions metric
     *
     * @returns the next Assertion DSL step (condition in the next step can be specified with a floating point value)
     */
    percent(): AssertionWithPathAndTarget;
}
/**
 * Step 4 of the Assertion DSL (path and target defined). Immutable, so all methods return a new
 * occurrence and leave the original unmodified.
 */
export interface AssertionWithPathAndTarget {
    /**
     * Specify the metric must be strictly less than the expected value
     *
     * @param value - the value
     * @returns a complete Assertion
     */
    lt(value: number): Assertion;
    /**
     * Specify the metric must be less than or equal to the expected value
     *
     * @param value - the value
     * @returns a complete Assertion
     */
    lte(value: number): Assertion;
    /**
     * Specify the metric must be strictly greater than the expected value
     *
     * @param value - the value
     * @returns a complete Assertion
     */
    gt(value: number): Assertion;
    /**
     * Specify the metric must be greater than or equal to the expected value
     *
     * @param value - the value
     * @returns a complete Assertion
     */
    gte(value: number): Assertion;
    /**
     * Specify the metric must be included in the given range
     *
     * @param min - the min, included
     * @param max - the max, included
     * @param inclusive - if bounds must be included in the range
     * @returns a complete Assertion
     */
    between(min: number, max: number, inclusive?: boolean): Assertion;
    /**
     * Specify the metric must be included in a range defined around a mean value with a half range
     * expressed as an absolute value
     *
     * @param mean - the mean of the range
     * @param plusOrMinus - the range half width
     * @param inclusive - if bounds must be included in the range
     * @returns a complete Assertion
     */
    around(mean: number, plusOrMinus: number, inclusive?: boolean): Assertion;
    /**
     * Specify the metric must be included in a range defined around a mean value with a half range
     * expressed as an percentage of the mean value
     *
     * @param mean - the mean of the range
     * @param percentDeviation - the range half width expressed as a percent of the mean
     * @param inclusive - if bounds must be included in the range
     * @returns a complete Assertion
     */
    deviatesAround(mean: number, percentDeviation: number, inclusive?: boolean): Assertion;
    /**
     * Specify the metric must be equal to an expected value
     *
     * @param value - the expected value
     * @returns a complete Assertion
     */
    is(value: number): Assertion;
    /**
     * Specify the metric must be included in a set of values
     *
     * @param values - the expected values
     * @returns a complete Assertion
     */
    in(...values: number[]): Assertion;
}
export interface Assertion extends Wrapper<JvmAssertion> {
}
