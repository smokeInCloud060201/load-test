import { Session, SessionTo } from "../session";
import { CheckBuilderCaptureGroup } from "./captureGroup";
import { CheckBuilderFind } from "./find";
import { CheckBuilderJsonOfTypeFind } from "./jsonOfTypeFind";
import { CheckBuilderJsonOfTypeMultipleFind } from "./jsonOfTypeMultipleFind";
import { CheckBuilderMultipleFind } from "./multipleFind";
export * from "./builder";
export * from "./captureGroup";
export * from "./condition";
export * from "./final";
export * from "./find";
export * from "./jsonOfTypeFind";
export * from "./jsonOfTypeMultipleFind";
export * from "./multipleFind";
export * from "./validate";
/**
 * Bootstrap a new bodyString check that extracts the full response message body as a String.
 * Encoding is either the one provided in the message (eg Content-Type charset attribute in HTTP),
 * or the one defined in gatling.conf.
 *
 * Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error.
 *
 * @returns the next DSL step
 */
export declare const bodyString: () => CheckBuilderFind<string>;
/**
 * Bootstrap a new bodyBytes check that extracts the full response message body as a byte array.
 *
 * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error.
 *
 * @returns the next DSL step
 */
export declare const bodyBytes: () => CheckBuilderFind<number[]>;
/**
 * Bootstrap a new bodyLength check that extracts the full response message body's binary length.
 *
 * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error.
 *
 * @returns the next DSL step
 */
export declare const bodyLength: () => CheckBuilderFind<number>;
export interface SubstringFunction {
    /**
     * Bootstrap a new substring check that extracts the indexes of the occurrences of a pattern in
     * the response's body String. Encoding is either the one provided in the message (eg Content-Type
     * charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param pattern - the searched pattern, expressed as a Gatling Expression Language String
     * @returns the next DSL step
     */
    (pattern: string): CheckBuilderMultipleFind<number>;
    /**
     * Bootstrap a new substring check that extracts the indexes of the occurrences of a pattern in
     * the response's body String. Encoding is either the one provided in the message (eg Content-Type
     * charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param pattern - the searched pattern, expressed as a function
     * @returns the next DSL step
     */
    (pattern: SessionTo<string>): CheckBuilderMultipleFind<number>;
}
export declare const substring: SubstringFunction;
export interface XpathFunction {
    /**
     * Bootstrap a new xpath check that extracts nodes with a <a
     * href="https://en.wikipedia.org/wiki/XPath">XPath</a> from response's body <a
     * href="https://en.wikipedia.org/wiki/XML">XML</a> document. Encoding is either the one provided
     * in the message (eg Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param path - the searched path, expressed as a Gatling Expression Language String
     * @returns the next DSL step
     */
    (path: string): CheckBuilderMultipleFind<string>;
    /**
     * Bootstrap a new xpath check that extracts nodes with a <a
     * href="https://en.wikipedia.org/wiki/XPath">XPath</a> from response's body <a
     * href="https://en.wikipedia.org/wiki/XML">XML</a> document. Encoding is either the one provided
     * in the message (eg Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param path - the searched path, expressed as a function
     * @returns the next DSL step
     */
    (path: SessionTo<string>): CheckBuilderMultipleFind<string>;
    /**
     * Bootstrap a new xpath check that extracts nodes with a <a
     * href="https://en.wikipedia.org/wiki/XPath">XPath</a> from response's body <a
     * href="https://en.wikipedia.org/wiki/XML">XML</a> document. Encoding is either the one provided
     * in the message (eg Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param path - the searched path, expressed as a Gatling Expression Language String
     * @param namespaces - the XML <a href="https://en.wikipedia.org/wiki/XML_namespace">namespaces</a>
     *     used in the document
     * @returns the next DSL step
     */
    (path: string, namespaces: Record<string, string>): CheckBuilderMultipleFind<string>;
    /**
     * Bootstrap a new xpath check that extracts nodes with a <a
     * href="https://en.wikipedia.org/wiki/XPath">XPath</a> from response's body <a
     * href="https://en.wikipedia.org/wiki/XML">XML</a> document. Encoding is either the one provided
     * in the message (eg Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param path - the searched path, expressed as a function
     * @param namespaces - the XML <a href="https://en.wikipedia.org/wiki/XML_namespace">namespaces</a>
     *     used in the document
     * @returns the next DSL step
     */
    (path: SessionTo<string>, namespaces: Record<string, string>): CheckBuilderMultipleFind<string>;
}
export declare const xpath: XpathFunction;
export interface CssFunction {
    /**
     * Bootstrap a new css check that extracts nodes with a <a
     * href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">CSS Selector</a> from
     * response's body HTML document. Encoding is either the one provided in the message (eg
     * Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param selector - the searched selector, expressed as a Gatling Expression Language String
     * @returns the next DSL step
     */
    (selector: string): CheckBuilderMultipleFind<string>;
    /**
     * Bootstrap a new css check that extracts nodes with a <a
     * href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">CSS Selector</a> from
     * response's body HTML document. Encoding is either the one provided in the message (eg
     * Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param selector - the searched selector, expressed as a function
     * @returns the next DSL step
     */
    (selector: SessionTo<string>): CheckBuilderMultipleFind<string>;
    /**
     * Bootstrap a new css check that extracts nodes with a <a
     * href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">CSS Selector</a> from
     * response's body HTML document. Encoding is either the one provided in the message (eg
     * Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param selector - the searched selector, expressed as a Gatling Expression Language String
     * @param nodeAttribute - the attribute of the selected nodes to capture, if not the node itself
     * @returns the next DSL step
     */
    (selector: string, nodeAttribute: string): CheckBuilderMultipleFind<string>;
    /**
     * Bootstrap a new css check that extracts nodes with a <a
     * href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">CSS Selector</a> from
     * response's body HTML document. Encoding is either the one provided in the message (eg
     * Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param selector - the searched selector, expressed as a function
     * @param nodeAttribute - the attribute of the selected nodes to capture, if not the node itself
     * @returns the next DSL step
     */
    (selector: SessionTo<string>, nodeAttribute: string): CheckBuilderMultipleFind<string>;
}
export declare const css: CssFunction;
export interface FormFunction {
    /**
     * Bootstrap a new form check that extracts an HTML form's input nodes with a <a
     * href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">CSS Selector</a> from
     * response's body HTML document. Encoding is either the one provided in the message (eg
     * Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param selector - the searched selector, expressed as a Gatling Expression Language String
     * @returns the next DSL step
     */
    (selector: string): CheckBuilderMultipleFind<Record<string, unknown>>;
    /**
     * Bootstrap a new form check that extracts an HTML form's input nodes with a <a
     * href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">CSS Selector</a> from
     * response's body HTML document. Encoding is either the one provided in the message (eg
     * Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * error
     *
     * @param selector - the searched selector, expressed as a function
     * @returns the next DSL step
     */
    (selector: SessionTo<string>): CheckBuilderMultipleFind<Record<string, unknown>>;
}
export declare const form: FormFunction;
export interface JsonPathFunction {
    /**
     * Bootstrap a new jsonPath check that extracts nodes with a <a
     * href="https://goessner.net/articles/JsonPath/">JsonPath</a> path from response's body JSON
     * tree.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * {@link IllegalArgumentException}
     *
     * @param path - the searched path, expressed as a Gatling Expression Language String
     * @returns the next DSL step
     */
    (path: string): CheckBuilderJsonOfTypeMultipleFind;
    /**
     * Bootstrap a new jsonPath check that extracts nodes with a <a
     * href="https://goessner.net/articles/JsonPath/">JsonPath</a> path from response's body JSON
     * tree.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * {@link IllegalArgumentException}
     *
     * @param path - the searched path, expressed as a function
     * @returns the next DSL step
     */
    (path: (session: Session) => string): CheckBuilderJsonOfTypeMultipleFind;
}
export declare const jsonPath: JsonPathFunction;
export interface JmesPathFunction {
    /**
     * Bootstrap a new jmesPath check that extracts nodes with a <a
     * href="https://jmespath.org/">JMESPath</a> path from response's body JSON tree.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * {@link IllegalArgumentException}
     *
     * @param path - the searched path, expressed as a Gatling Expression Language String
     * @returns the next DSL step
     */
    (path: string): CheckBuilderJsonOfTypeFind;
    /**
     * Bootstrap a new jmesPath check that extracts nodes with a <a
     * href="https://jmespath.org/">JMESPath</a> path from response's body JSON tree.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * {@link IllegalArgumentException}
     *
     * @param path - the searched path, expressed as a function
     * @returns the next DSL step
     */
    (path: (session: Session) => string): CheckBuilderJsonOfTypeFind;
}
export declare const jmesPath: JmesPathFunction;
export interface JsonpJsonPathFunction {
    /**
     * Bootstrap a new jsonpJsonPath check that extracts nodes with a <a
     * href="https://goessner.net/articles/JsonPath/">JsonPath</a> path from response's body <a
     * href="https://en.wikipedia.org/wiki/JSONP">JSONP</a> payload.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * {@link IllegalArgumentException}
     *
     * @param path - the searched path, expressed as a Gatling Expression Language String
     * @returns the next DSL step
     */
    (path: string): CheckBuilderJsonOfTypeMultipleFind;
    /**
     * Bootstrap a new jsonpJsonPath check that extracts nodes with a <a
     * href="https://goessner.net/articles/JsonPath/">JsonPath</a> path from response's body <a
     * href="https://en.wikipedia.org/wiki/JSONP">JSONP</a> payload.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * {@link IllegalArgumentException}
     *
     * @param path - the searched path, expressed as a function
     * @returns the next DSL step
     */
    (path: (session: Session) => string): CheckBuilderJsonOfTypeMultipleFind;
}
export declare const jsonpJsonPath: JsonpJsonPathFunction;
export interface JsonpJmesPathFunction {
    /**
     * Bootstrap a new jsonpJmesPath check that extracts nodes with a <a
     * href="https://jmespath.org/">JMESPath</a> path from response's body JSON <a
     * href="https://en.wikipedia.org/wiki/JSONP">JSONP</a> payload.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * {@link IllegalArgumentException}
     *
     * @param path - the searched path, expressed as a Gatling Expression Language String
     * @returns the next DSL step
     */
    (path: string): CheckBuilderJsonOfTypeFind;
    /**
     * Bootstrap a new jsonpJmesPath check that extracts nodes with a <a
     * href="https://jmespath.org/">JMESPath</a> path from response's body JSON <a
     * href="https://en.wikipedia.org/wiki/JSONP">JSONP</a> payload.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * {@link IllegalArgumentException}
     *
     * @param path - the searched path, expressed as a function
     * @returns the next DSL step
     */
    (path: (session: Session) => string): CheckBuilderJsonOfTypeFind;
}
export declare const jsonpJmesPath: JsonpJmesPathFunction;
export interface RegexFunction {
    /**
     * Bootstrap a new regex check that extracts capture groups with a <a
     * href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Java Regular
     * Expression</a> from response's body String. Encoding is either the one provided in the message
     * (eg Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * {@link IllegalArgumentException}
     *
     * @param pattern the searched pattern, expressed as a Gatling Expression Language String
     * @return the next DSL step
     */
    (pattern: string): CheckBuilderCaptureGroup;
    /**
     * Bootstrap a new regex check that extracts capture groups with a <a
     * href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Java Regular
     * Expression</a> from response's body String. Encoding is either the one provided in the message
     * (eg Content-Type charset attribute in HTTP), or the one defined in gatling.conf.
     *
     * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
     * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
     * {@link IllegalArgumentException}
     *
     * @param pattern the searched pattern, expressed as a function
     * @return the next DSL step
     */
    (pattern: (session: Session) => string): CheckBuilderCaptureGroup;
}
export declare const regex: RegexFunction;
/**
 * Bootstrap a new md5 check that extracts the <a href="https://en.wikipedia.org/wiki/MD5">MD5</a>
 * checksum of the response's body.
 *
 * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error
 *
 * @returns the next DSL step
 */
export declare const md5: () => CheckBuilderFind<string>;
/**
 * Bootstrap a new sha1 check that extracts the <a
 * href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> checksum of the response's body.
 *
 * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error
 *
 * @returns the next DSL step
 */
export declare const sha1: () => CheckBuilderFind<string>;
/**
 * Bootstrap a new responseTimeInMillis check that extracts the response time of the request.
 *
 * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error
 *
 * @returns the next DSL step
 */
export declare const responseTimeInMillis: () => CheckBuilderFind<number>;
