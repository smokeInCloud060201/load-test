"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.responseTimeInMillis = exports.sha1 = exports.md5 = exports.regex = exports.jsonpJmesPath = exports.jsonpJsonPath = exports.jmesPath = exports.jsonPath = exports.form = exports.css = exports.xpath = exports.substring = exports.bodyLength = exports.bodyBytes = exports.bodyString = void 0;
const jvm_types_1 = require("@gatling.io/jvm-types");
const session_1 = require("../session");
const captureGroup_1 = require("./captureGroup");
const byteArrays_1 = require("../gatlingJvm/byteArrays");
const final_1 = require("./final");
const find_1 = require("./find");
const jsonOfTypeFind_1 = require("./jsonOfTypeFind");
const jsonOfTypeMultipleFind_1 = require("./jsonOfTypeMultipleFind");
const multipleFind_1 = require("./multipleFind");
__exportStar(require("./builder"), exports);
__exportStar(require("./captureGroup"), exports);
__exportStar(require("./condition"), exports);
__exportStar(require("./final"), exports);
__exportStar(require("./find"), exports);
__exportStar(require("./jsonOfTypeFind"), exports);
__exportStar(require("./jsonOfTypeMultipleFind"), exports);
__exportStar(require("./multipleFind"), exports);
__exportStar(require("./validate"), exports);
/**
 * Bootstrap a new bodyString check that extracts the full response message body as a String.
 * Encoding is either the one provided in the message (eg Content-Type charset attribute in HTTP),
 * or the one defined in gatling.conf.
 *
 * Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error.
 *
 * @returns the next DSL step
 */
const bodyString = () => (0, find_1.wrapCheckBuilderFind)(jvm_types_1.CoreDsl.bodyString());
exports.bodyString = bodyString;
/**
 * Bootstrap a new bodyBytes check that extracts the full response message body as a byte array.
 *
 * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error.
 *
 * @returns the next DSL step
 */
const bodyBytes = () => ({
    ...(0, find_1.wrapCheckBuilderFind)(jvm_types_1.CoreDsl.bodyBytes()),
    is: (expected) => (0, final_1.wrapCheckBuilderFinal)(typeof expected === "function"
        ? jvm_types_1.CoreDsl.bodyBytes().is((0, byteArrays_1.asByteArrayFunction)((0, session_1.underlyingSessionTo)(expected)))
        : jvm_types_1.CoreDsl.bodyBytes().is((0, byteArrays_1.asByteArray)(expected))),
    not: (expected) => (0, final_1.wrapCheckBuilderFinal)(typeof expected === "function"
        ? jvm_types_1.CoreDsl.bodyBytes().not((0, byteArrays_1.asByteArrayFunction)((0, session_1.underlyingSessionTo)(expected)))
        : jvm_types_1.CoreDsl.bodyBytes().not((0, byteArrays_1.asByteArray)(expected)))
});
exports.bodyBytes = bodyBytes;
/**
 * Bootstrap a new bodyLength check that extracts the full response message body's binary length.
 *
 * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error.
 *
 * @returns the next DSL step
 */
const bodyLength = () => (0, find_1.wrapCheckBuilderFind)(jvm_types_1.CoreDsl.bodyLength());
exports.bodyLength = bodyLength;
const substring = (pattern) => (0, multipleFind_1.wrapCheckBuilderMultipleFind)((typeof pattern === "function"
    ? jvm_types_1.CoreDsl.substring((0, session_1.underlyingSessionTo)(pattern))
    : jvm_types_1.CoreDsl.substring(pattern)));
exports.substring = substring;
const xpath = (path, namespaces) => {
    if (typeof path === "function") {
        if (namespaces !== undefined) {
            return (0, multipleFind_1.wrapCheckBuilderMultipleFind)(jvm_types_1.CoreDsl.xpath((0, session_1.underlyingSessionTo)(path), namespaces)); // TODO change type of java.util.Map in java2typescript
        }
        else {
            return (0, multipleFind_1.wrapCheckBuilderMultipleFind)(jvm_types_1.CoreDsl.xpath((0, session_1.underlyingSessionTo)(path)));
        }
    }
    else {
        if (namespaces !== undefined) {
            return (0, multipleFind_1.wrapCheckBuilderMultipleFind)(jvm_types_1.CoreDsl.xpath(path, namespaces)); // TODO change type of java.util.Map in java2typescript
        }
        else {
            return (0, multipleFind_1.wrapCheckBuilderMultipleFind)(jvm_types_1.CoreDsl.xpath(path));
        }
    }
};
exports.xpath = xpath;
const css = (selector, nodeAttribute) => {
    if (typeof selector === "function") {
        if (nodeAttribute !== undefined) {
            return (0, multipleFind_1.wrapCheckBuilderMultipleFind)(jvm_types_1.CoreDsl.css((0, session_1.underlyingSessionTo)(selector), nodeAttribute));
        }
        else {
            return (0, multipleFind_1.wrapCheckBuilderMultipleFind)(jvm_types_1.CoreDsl.css((0, session_1.underlyingSessionTo)(selector)));
        }
    }
    else {
        if (nodeAttribute !== undefined) {
            return (0, multipleFind_1.wrapCheckBuilderMultipleFind)(jvm_types_1.CoreDsl.css(selector, nodeAttribute));
        }
        else {
            return (0, multipleFind_1.wrapCheckBuilderMultipleFind)(jvm_types_1.CoreDsl.css(selector));
        }
    }
};
exports.css = css;
// TODO check what type the values in the Map actually have, and if they are usable in Javascript
const form = (selector) => (0, multipleFind_1.wrapCheckBuilderMultipleFind)((typeof selector === "function"
    ? jvm_types_1.CoreDsl.form((0, session_1.underlyingSessionTo)(selector))
    : jvm_types_1.CoreDsl.form(selector)) // TODO change type of java.util.Map in java2typescript
);
exports.form = form;
const jsonPath = (path) => (0, jsonOfTypeMultipleFind_1.wrapCheckBuilderJsonOfTypeMultipleFind)(typeof path === "function" ? jvm_types_1.CoreDsl.jsonPath((0, session_1.underlyingSessionTo)(path)) : jvm_types_1.CoreDsl.jsonPath(path));
exports.jsonPath = jsonPath;
const jmesPath = (path) => (0, jsonOfTypeFind_1.wrapCheckBuilderJsonOfTypeFind)(typeof path === "function" ? jvm_types_1.CoreDsl.jmesPath((0, session_1.underlyingSessionTo)(path)) : jvm_types_1.CoreDsl.jmesPath(path));
exports.jmesPath = jmesPath;
const jsonpJsonPath = (path) => (0, jsonOfTypeMultipleFind_1.wrapCheckBuilderJsonOfTypeMultipleFind)(typeof path === "function" ? jvm_types_1.CoreDsl.jsonpJsonPath((0, session_1.underlyingSessionTo)(path)) : jvm_types_1.CoreDsl.jsonpJsonPath(path));
exports.jsonpJsonPath = jsonpJsonPath;
const jsonpJmesPath = (path) => (0, jsonOfTypeFind_1.wrapCheckBuilderJsonOfTypeFind)(typeof path === "function" ? jvm_types_1.CoreDsl.jsonpJmesPath((0, session_1.underlyingSessionTo)(path)) : jvm_types_1.CoreDsl.jsonpJmesPath(path));
exports.jsonpJmesPath = jsonpJmesPath;
const regex = (pattern) => (0, captureGroup_1.wrapCheckBuilderCaptureGroup)(typeof pattern === "function" ? jvm_types_1.CoreDsl.regex((0, session_1.underlyingSessionTo)(pattern)) : jvm_types_1.CoreDsl.regex(pattern));
exports.regex = regex;
/**
 * Bootstrap a new md5 check that extracts the <a href="https://en.wikipedia.org/wiki/MD5">MD5</a>
 * checksum of the response's body.
 *
 * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error
 *
 * @returns the next DSL step
 */
const md5 = () => (0, find_1.wrapCheckBuilderFind)(jvm_types_1.CoreDsl.md5());
exports.md5 = md5;
/**
 * Bootstrap a new sha1 check that extracts the <a
 * href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> checksum of the response's body.
 *
 * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error
 *
 * @returns the next DSL step
 */
const sha1 = () => (0, find_1.wrapCheckBuilderFind)(jvm_types_1.CoreDsl.sha1());
exports.sha1 = sha1;
/**
 * Bootstrap a new responseTimeInMillis check that extracts the response time of the request.
 *
 * <p>Note: On contrary to the Scala DSL, the compiler can't check the availability of this check
 * type for your protocol. If the protocol you're using doesn't support it, you'll get a runtime
 * error
 *
 * @returns the next DSL step
 */
const responseTimeInMillis = () => (0, find_1.wrapCheckBuilderFind)(jvm_types_1.CoreDsl.responseTimeInMillis());
exports.responseTimeInMillis = responseTimeInMillis;
