"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.enterpriseStart = exports.enterpriseDeploy = exports.enterprisePackage = void 0;
const archiver_1 = __importDefault(require("archiver"));
const fs_1 = __importDefault(require("fs"));
const promises_1 = require("stream/promises");
const zlib_1 = require("zlib");
const dependencies_1 = require("./dependencies");
const java_1 = require("./java");
const log_1 = require("./log");
const enterprisePackage = async (options) => {
    log_1.logger.info(`Packaging a Gatling simulation with options:
 - bundleFile: ${options.bundleFile}
 - packageFile: ${options.packageFile}`);
    const manifest = generateManifest(options.simulations.map((s) => s.name));
    const output = fs_1.default.createWriteStream(options.packageFile);
    const archive = (0, archiver_1.default)("zip", {
        zlib: { level: zlib_1.constants.Z_MAX_LEVEL }
    });
    archive.on("warning", (err) => {
        // The pipeline will rethrow errors but not warnings. We don't want to ignore warnings from the archiver, because
        // they include things like 'no such file or directory'.
        throw err;
    });
    archive.file(options.bundleFile, { name: "bundle.js" });
    archive.append(Buffer.from(manifest), { name: "META-INF/MANIFEST.MF" });
    archive.directory(options.resourcesFolder + "/", false);
    archive.finalize();
    await (0, promises_1.pipeline)(archive, output);
    log_1.logger.info(`Package for Gatling Enterprise created at ${options.packageFile}`);
};
exports.enterprisePackage = enterprisePackage;
const generateManifest = (simulationNames) => {
    const utf8Encoder = new TextEncoder();
    const eol = utf8Encoder.encode("\n");
    const continuation = utf8Encoder.encode("\n ");
    const lines = [
        "Manifest-Version: 1.0",
        "Specification-Vendor: GatlingCorp",
        "Gatling-Context: js",
        `Gatling-Version: ${dependencies_1.versions.gatling.core}`,
        "Gatling-Packager: js-cli",
        `Gatling-Packager-Version: ${dependencies_1.versions.gatling.jsAdapter}`,
        `Gatling-Simulations: ${simulationNames.join(",")}`,
        `Java-Version: ${dependencies_1.versions.java.compilerRelease}`
    ];
    const pkg = getPackageNameAndVersion();
    lines.push(`Implementation-Title: ${pkg.name}`);
    if (pkg.version !== undefined) {
        lines.push(`Implementation-Version: ${pkg.version}`);
    }
    let totalLength = 0;
    const buffer = [];
    for (const line of lines) {
        let lineLength = 0;
        for (const char of line) {
            const bytes = utf8Encoder.encode(char);
            const byteLength = bytes.byteLength;
            if (lineLength + byteLength > 71) {
                buffer.push(continuation);
                buffer.push(bytes);
                // reset length for the new line (with +1 for leading space)
                lineLength = byteLength + 1;
                totalLength += byteLength + 2;
            }
            else {
                buffer.push(bytes);
                lineLength += byteLength;
                totalLength += byteLength;
            }
        }
        buffer.push(eol);
        totalLength += 1;
    }
    const manifest = new Uint8Array(totalLength);
    let cursor = 0;
    for (const elt of buffer) {
        manifest.set(elt, cursor);
        cursor += elt.byteLength;
    }
    return manifest;
};
const getPackageNameAndVersion = () => {
    // npm_package_* env vars are available when launching CLI with npx
    let name = process.env.npm_package_name;
    let version = process.env.npm_package_version;
    // otherwise, try to read from package.json file
    if (name === undefined || version === undefined) {
        if (!fs_1.default.existsSync("package.json")) {
            throw Error("package.json not found");
        }
        const pkg = JSON.parse(fs_1.default.readFileSync("package.json", "utf-8"));
        if (name === undefined) {
            if (typeof pkg.name === "string") {
                name = pkg.name;
            }
            else {
                throw Error("package.json does not contain a valid package name");
            }
        }
        if (version === undefined && typeof pkg.version === "string") {
            version = pkg.version;
        }
    }
    return { name: name, version: version };
};
const javaArgsFromPluginOptions = (options) => {
    const javaArgs = [];
    // Base
    javaArgs.push(`-Dgatling.enterprise.apiUrl=${options.apiUrl}`);
    javaArgs.push(`-Dgatling.enterprise.webAppUrl=${options.webAppUrl}`);
    if (options.apiToken !== undefined) {
        javaArgs.push(`-Dgatling.enterprise.apiToken=${options.apiToken}`);
    }
    // Plugin configuration
    if (options.controlPlaneUrl !== undefined) {
        javaArgs.push(`-Dgatling.enterprise.controlPlaneUrl=${options.controlPlaneUrl}`);
    }
    javaArgs.push("-Dgatling.enterprise.buildTool=js-cli");
    javaArgs.push(`-Dgatling.enterprise.pluginVersion=${dependencies_1.versions.gatling.jsAdapter}`);
    if (options.nonInteractive) {
        javaArgs.push(`-Dgatling.enterprise.batchMode=true`);
    }
    return javaArgs;
};
const javaArgsFromDeployOptions = (options) => {
    const javaArgs = javaArgsFromPluginOptions(options);
    // Descriptor file
    javaArgs.push(`-Dgatling.enterprise.baseDirectory=${process.cwd()}`);
    javaArgs.push(`-Dgatling.enterprise.packageDescriptorFilename=${options.packageDescriptorFilename}`);
    // Deployment info
    javaArgs.push(`-Dgatling.enterprise.packageFile=${options.packageFile}`);
    javaArgs.push(`-Dgatling.enterprise.artifactId=${getPackageNameAndVersion().name}`);
    return javaArgs;
};
const enterpriseDeploy = async (options) => {
    const additionalClasspathElements = [options.resourcesFolder];
    const javaArgs = javaArgsFromDeployOptions(options);
    if (process.env["DEBUG"] === "true") {
        log_1.logger.debug("Java arguments:");
        for (let i = 0; i < javaArgs.length; i++) {
            log_1.logger.debug("  " + javaArgs[i]);
        }
    }
    return (0, java_1.runJavaProcess)(options, "io.gatling.plugin.cli.EnterpriseDeploy", additionalClasspathElements, javaArgs, []);
};
exports.enterpriseDeploy = enterpriseDeploy;
const enterpriseStart = async (options) => {
    const additionalClasspathElements = [options.resourcesFolder];
    const javaArgs = javaArgsFromDeployOptions(options);
    // Start
    if (options.enterpriseSimulation !== undefined) {
        javaArgs.push(`-Dgatling.enterprise.simulationName=${options.enterpriseSimulation}`);
    }
    if (options.runTitle !== undefined) {
        javaArgs.push(`-Dgatling.enterprise.runTitle=${options.runTitle}`);
    }
    if (options.runDescription !== undefined) {
        javaArgs.push(`-Dgatling.enterprise.runDescription=${options.runDescription}`);
    }
    if (options.waitForRunEnd) {
        javaArgs.push("-Dgatling.enterprise.waitForRunEnd=true");
    }
    if (process.env["DEBUG"] === "true") {
        log_1.logger.debug("Java arguments:");
        for (let i = 0; i < javaArgs.length; i++) {
            log_1.logger.debug("  " + javaArgs[i]);
        }
    }
    return (0, java_1.runJavaProcess)(options, "io.gatling.plugin.cli.EnterpriseStart", additionalClasspathElements, javaArgs, []);
};
exports.enterpriseStart = enterpriseStart;
