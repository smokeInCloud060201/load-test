"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.polyfill = void 0;
const url_1 = require("url");
const path_1 = require("path");
// This is largely inspired by https://github.com/cyco130/esbuild-plugin-polyfill-node
const polyfill = () => ({
    name: "gatling-js-polyfill",
    setup: async (build) => {
        // modules
        const jspmResolved = await resolveImport(`@jspm/core/nodelibs/fs`);
        build.onResolve({ filter: polyfillsFilter }, async ({ path }) => {
            const [, , moduleName] = path.match(polyfillsFilter);
            const resolved = customPolyfills.find((name) => name === moduleName)
                ? (0, path_1.resolve)((0, path_1.dirname)(__filename), `../../polyfills/${moduleName}.js`)
                : (0, path_1.resolve)(jspmResolved, `../../browser/${moduleName}.js`);
            return { path: resolved };
        });
        // Globals
        build.initialOptions.inject = build.initialOptions.inject || [];
        const injectGlobal = (name) => build.initialOptions.inject.push((0, path_1.resolve)((0, path_1.dirname)(__filename), `../../polyfills/${name}.js`));
        injectGlobal("global");
    }
});
exports.polyfill = polyfill;
const customPolyfills = ["crypto"];
const jspmPolyfills = ["buffer", "path", "string_decoder"];
// Other available jspm-core modules:
// "_stream_duplex"
// "_stream_passthrough"
// "_stream_readable"
// "_stream_transform"
// "_stream_writable"
// "assert"
// "assert/strict"
// "async_hooks"
// "child_process"
// "cluster"
// "console"
// "constants"
// "crypto"
// "dgram"
// "diagnostics_channel"
// "dns"
// "domain"
// "events"
// "fs"
// "fs/promises"
// "http"
// "http2"
// "https"
// "module"
// "net"
// "os"
// "perf_hooks"
// "process"
// "punycode"
// "querystring"
// "readline"
// "repl"
// "stream"
// "sys"
// "timers"
// "timers/promises"
// "tls"
// "tty"
// "url"
// "util"
// "v8"
// "vm"
// "wasi"
// "worker_threads"
// "zlib"
const polyfillsFilter = new RegExp(`^(node:)?(${jspmPolyfills.concat(customPolyfills).join("|")})$`);
let importMetaResolve;
const importMetaUrl = (0, url_1.pathToFileURL)(__filename).href;
const resolveImport = async (specifier) => {
    if (!importMetaResolve) {
        importMetaResolve = (await import("import-meta-resolve")).resolve;
    }
    const resolved = importMetaResolve(specifier, importMetaUrl);
    return (0, url_1.fileURLToPath)(resolved);
};
