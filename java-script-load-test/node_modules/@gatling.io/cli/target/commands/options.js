"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForRunEndOptionValue = exports.waitForRunEndOption = exports.runDescriptionOptionValue = exports.runDescriptionOption = exports.runTitleOptionValue = exports.runTitleOption = exports.enterpriseSimulationOptionValue = exports.enterpriseSimulationOption = exports.packageDescriptorFilenameOptionValue = exports.packageDescriptorFilenameOption = exports.controlPlaneUrlOptionValue = exports.controlPlaneUrlOption = exports.apiTokenOptionValue = exports.apiTokenOption = exports.webAppUrlOptionValue = exports.webAppUrlOption = exports.apiUrlOptionValue = exports.apiUrlOption = exports.bundleFileArgument = exports.parseRunParametersArgument = exports.runParametersArgument = exports.postmanOptionValueWithDefaults = exports.postmanOption = exports.nonInteractiveOptionValue = exports.nonInteractiveOption = exports.memoryOptionValue = exports.memoryOption = exports.jvmClasspathMandatoryOptionValue = exports.jvmClasspathMandatoryOption = exports.graalvmHomeMandatoryOptionValue = exports.graalvmHomeMandatoryOption = exports.typescriptOptionValueWithDefaults = exports.typescriptOption = exports.resultsFolderOptionValue = exports.resultsFolderOption = exports.resourcesFolderOptionValue = exports.resourcesFolderOption = exports.packageFileOptionValue = exports.packageFileOption = exports.bundleFileOptionValue = exports.bundleFileOption = exports.simulationMandatoryOptionValue = exports.simulationMandatoryOption = exports.simulationOptionValueWithDefaults = exports.simulationOption = exports.sourcesFolderOptionValue = exports.sourcesFolderOption = exports.gatlingHomeOptionValueWithDefaults = exports.gatlingHomeOption = void 0;
const commander_1 = require("commander");
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const readline_1 = require("../readline");
const log_1 = require("../log");
const getStringValueOptional = (option) => (options) => {
    const value = options[option.attributeName()];
    if (typeof value === "string" || typeof value === "undefined") {
        return value;
    }
    else {
        throw Error(`Expected type string|undefined for attribute ${option.attributeName()}, got ${typeof value} - please report this as a bug.`);
    }
};
const getStringValueMandatory = (option) => (options) => {
    const value = options[option.attributeName()];
    if (typeof value === "string") {
        return value;
    }
    else {
        throw Error(`Expected type string for attribute ${option.attributeName()}, got ${typeof value} - please report this as a bug.`);
    }
};
const getBooleanValueOptional = (option) => (options) => {
    const value = options[option.attributeName()];
    if (typeof value === "boolean" || typeof value === "undefined") {
        return value;
    }
    else {
        throw Error(`Expected type boolean|undefined for attribute ${option.attributeName()}, got ${typeof value} - please report this as a bug.`);
    }
};
const getBooleanValueMandatory = (option) => (options) => {
    const value = options[option.attributeName()];
    if (typeof value === "boolean") {
        return value;
    }
    else {
        throw Error(`Expected type boolean for attribute ${option.attributeName()}, got ${typeof value} - please report this as a bug.`);
    }
};
const getNumberValueOptional = (option) => (options) => {
    const value = options[option.attributeName()];
    if (typeof value === "number" || typeof value === "undefined") {
        return value;
    }
    else {
        throw Error(`Expected type number|undefined for attribute ${option.attributeName()}, got ${typeof value} - please report this as a bug.`);
    }
};
exports.gatlingHomeOption = new commander_1.Option("--gatling-home <value>", 'The folder used to download and install Gatling components (default: "<user home>/.gatling")');
const gatlingHomeOptionValueWithDefaults = (options) => getStringValueOptional(exports.gatlingHomeOption)(options) || `${os_1.default.homedir()}/.gatling`;
exports.gatlingHomeOptionValueWithDefaults = gatlingHomeOptionValueWithDefaults;
exports.sourcesFolderOption = new commander_1.Option("--sources-folder <value>", "The sources folder path").default("src");
exports.sourcesFolderOptionValue = getStringValueMandatory(exports.sourcesFolderOption);
exports.simulationOption = new commander_1.Option("--simulation <value>", "The simulation entry point function name (default: if only one *.gatling.js or *.gatling.ts file is found, will execute that simulation)");
const simulationOptionValueWithDefaults = (options, simulationsFound, interactive) => {
    const declaredSimulation = getStringValueOptional(exports.simulationOption)(options);
    if (declaredSimulation !== undefined) {
        return declaredSimulation;
    }
    else if (simulationsFound.length === 1) {
        return simulationsFound[0].name;
    }
    else if (simulationsFound.length === 0) {
        throw new Error("No simulation found, simulations must be defined in a <simulation name>.gatling.js or <simulation name>.gatling.ts file)");
    }
    else if (interactive) {
        const sortedSimulations = simulationsFound.sort((a, b) => a.name.localeCompare(b.name));
        const idx = (0, readline_1.keyInSelectPaginated)(sortedSimulations.map((s) => s.name), "Choose a simulation to run");
        if (idx >= 0) {
            const simulation = sortedSimulations[idx].name;
            log_1.logger.info(`Simulation '${simulation}' was chosen.`);
            return simulation;
        }
        else {
            throw new Error("Simulation choice was cancelled.");
        }
    }
    else {
        throw new Error(`Several simulations found, specify one using the --simulation option (available simulations: ${simulationsFound.map((s) => s.name)})`);
    }
};
exports.simulationOptionValueWithDefaults = simulationOptionValueWithDefaults;
exports.simulationMandatoryOption = new commander_1.Option("--simulation <value>", "The simulation entry point function name").makeOptionMandatory(true);
exports.simulationMandatoryOptionValue = getStringValueMandatory(exports.simulationMandatoryOption);
exports.bundleFileOption = new commander_1.Option("--bundle-file <value>", "The target bundle file path when building simulations (must have a .js extension)")
    .default("target/bundle.js")
    .argParser((value) => {
    if (!value.endsWith(".js")) {
        throw Error(`'${value}' is not a valid bundle file path: should have a .js extension`);
    }
    return value;
});
exports.bundleFileOptionValue = getStringValueMandatory(exports.bundleFileOption);
exports.packageFileOption = new commander_1.Option("--package-file <value>", "The target package file path when packaging simulations for Gatling Enterprise (must have a .zip extension)")
    .default("target/package.zip")
    .argParser((value) => {
    if (!value.endsWith(".zip")) {
        throw Error(`'${value}' is not a valid package file path: should have a .zip extension`);
    }
    return value;
});
exports.packageFileOptionValue = getStringValueMandatory(exports.packageFileOption);
exports.resourcesFolderOption = new commander_1.Option("--resources-folder <value>", "The resources folder path").default("resources");
exports.resourcesFolderOptionValue = getStringValueMandatory(exports.resourcesFolderOption);
exports.resultsFolderOption = new commander_1.Option("--results-folder <value>", "The results folder path").default("target/gatling");
exports.resultsFolderOptionValue = getStringValueMandatory(exports.resultsFolderOption);
exports.typescriptOption = new commander_1.Option("--typescript", "Use the typescript compiler to compile your code (default: true if the sourcesFolder contains any *.gatling.ts file, false otherwise)");
const typescriptOptionValueWithDefaults = (options, simulationsFound) => {
    const value = getBooleanValueOptional(exports.typescriptOption)(options);
    return value !== undefined ? value : simulationsFound.findIndex((s) => s.type === "typescript") >= 0;
};
exports.typescriptOptionValueWithDefaults = typescriptOptionValueWithDefaults;
exports.graalvmHomeMandatoryOption = new commander_1.Option("--graalvm-home <value>", "Path to the GraalVM home").makeOptionMandatory(true);
exports.graalvmHomeMandatoryOptionValue = getStringValueMandatory(exports.graalvmHomeMandatoryOption);
exports.jvmClasspathMandatoryOption = new commander_1.Option("--jvm-classpath <value>", "The classpath containing all Gatling JVM components").makeOptionMandatory(true);
exports.jvmClasspathMandatoryOptionValue = getStringValueMandatory(exports.jvmClasspathMandatoryOption);
exports.memoryOption = new commander_1.Option("--memory <value>", "Heap space memory size in MiB for Gatling. Half the total available memory is usually a good default, as the Gatling process will use more memory than just the heap space.").argParser((value) => {
    const parsedValue = parseInt(value, 10);
    if (isNaN(parsedValue)) {
        throw new Error(`${value} is not a valid memory size, must be an integer number`);
    }
    return parsedValue;
});
exports.memoryOptionValue = getNumberValueOptional(exports.memoryOption);
exports.nonInteractiveOption = new commander_1.Option("--non-interactive", "Switch to non-interactive mode and fail if no simulation is explicitly specified").default(false);
exports.nonInteractiveOptionValue = getBooleanValueMandatory(exports.nonInteractiveOption);
exports.postmanOption = new commander_1.Option("--postman <version>", "Postman compatibility option: adds polyfills, etc.").hideHelp();
const postmanOptionValueWithDefaults = (options) => {
    const postmanOptionValue = getStringValueOptional(exports.postmanOption)(options);
    if (postmanOptionValue !== undefined) {
        return postmanOptionValue;
    }
    else {
        try {
            const conf = JSON.parse(fs_1.default.readFileSync("package.json", { encoding: "utf-8", flag: "r" }));
            const withPostman = conf.dependencies?.["@gatling.io/postman"] !== undefined ||
                conf.devDependencies?.["@gatling.io/postman"] !== undefined;
            if (withPostman) {
                let directory = path_1.default.normalize(path_1.default.dirname("package.json"));
                const root = path_1.default.parse(directory).root;
                while (true) {
                    const file = path_1.default.join(directory, "node_modules", "@gatling.io", "postman", "package.json");
                    if (fs_1.default.existsSync(file)) {
                        const installedPackage = JSON.parse(fs_1.default.readFileSync(file, { encoding: "utf-8", flag: "r" }));
                        return installedPackage.version;
                    }
                    else if (directory === root) {
                        return undefined;
                    }
                    else {
                        directory = path_1.default.normalize(path_1.default.join(directory, ".."));
                    }
                }
            }
            else {
                return undefined;
            }
        }
        catch {
            return undefined;
        }
    }
};
exports.postmanOptionValueWithDefaults = postmanOptionValueWithDefaults;
exports.runParametersArgument = new commander_1.Argument("[optionKey=optionValue...]", "Specify one or more parameter which can be read in the simulation script with the getParameter() function; format must be key=value");
const parseRunParametersArgument = (args) => {
    const parsedParameters = {};
    for (const arg of args) {
        const i = arg.indexOf("=");
        if (i < 0) {
            throw Error(`Parameter '${arg}' is not valid: format should be key=value`);
        }
        else {
            const key = arg.slice(0, i).trim();
            parsedParameters[key] = arg.slice(i + 1);
        }
    }
    return parsedParameters;
};
exports.parseRunParametersArgument = parseRunParametersArgument;
exports.bundleFileArgument = new commander_1.Argument("[bundleFile]", "Specify the path to a Gatling JS bundle file to install; if not specified, bundle will be downloaded automatically");
exports.apiUrlOption = new commander_1.Option("--apiUrl <value>", "URL of the Gatling Enterprise API")
    .default("https://api.gatling.io")
    .hideHelp();
exports.apiUrlOptionValue = getStringValueMandatory(exports.apiUrlOption);
exports.webAppUrlOption = new commander_1.Option("--webAppUrl <value>", "URL of the Gatling Enterprise web app")
    .default("https://cloud.gatling.io")
    .hideHelp();
exports.webAppUrlOptionValue = getStringValueMandatory(exports.webAppUrlOption);
exports.apiTokenOption = new commander_1.Option("--api-token <value>", "API Token on Gatling Enterprise. Prefer configuration using `GATLING_ENTERPRISE_API_TOKEN` environment variable.");
exports.apiTokenOptionValue = getStringValueOptional(exports.apiTokenOption);
// Plugin configuration
exports.controlPlaneUrlOption = new commander_1.Option("--control-plane-url <value>", "URL of a control plane for Gatling Enterprise providing a private repository. If this parameter is provided, packages will be registered as private packages and uploaded through this private control plane.");
exports.controlPlaneUrlOptionValue = getStringValueOptional(exports.controlPlaneUrlOption);
// Descriptor file
exports.packageDescriptorFilenameOption = new commander_1.Option("--package-descriptor-filename <value>", "Path to a package descriptor inside the .gatling folder").default("package.conf");
exports.packageDescriptorFilenameOptionValue = getStringValueMandatory(exports.packageDescriptorFilenameOption);
// Deployment info
exports.enterpriseSimulationOption = new commander_1.Option("--enterprise-simulation <value>", "Specify the simulation name directly to bypass the prompt using the following command.");
exports.enterpriseSimulationOptionValue = getStringValueOptional(exports.enterpriseSimulationOption);
exports.runTitleOption = new commander_1.Option("--run-title <value>", "Allows setting a title for your run reports.");
exports.runTitleOptionValue = getStringValueOptional(exports.runTitleOption);
exports.runDescriptionOption = new commander_1.Option("--run-description <value>", "Allows setting a description for your run reports summary.");
exports.runDescriptionOptionValue = getStringValueOptional(exports.runDescriptionOption);
exports.waitForRunEndOption = new commander_1.Option("--wait-for-run-end", "Wait for the result after starting the simulation on Gatling Enterprise, and complete with an error if the simulation ends with any error status").default(false);
exports.waitForRunEndOptionValue = getBooleanValueMandatory(exports.waitForRunEndOption);
