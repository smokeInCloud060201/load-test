"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveBundle = exports.installBundleFile = exports.versions = void 0;
const fsSync = __importStar(require("node:fs"));
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const node_stream_zip_1 = __importDefault(require("node-stream-zip"));
const download_1 = require("./download");
const log_1 = require("../log");
const os_1 = require("./os");
const versions_1 = require("./versions");
var versions_2 = require("./versions");
Object.defineProperty(exports, "versions", { enumerable: true, get: function () { return versions_2.versions; } });
const installBundleFile = async (options) => {
    log_1.logger.info(`bundleFilePath: ${options.bundleFilePath}`);
    const zip = new node_stream_zip_1.default.async({ file: options.bundleFilePath });
    const metadata = await zip.entryData(metadataFileName);
    const { version } = JSON.parse(metadata.toString("utf-8"));
    if (version === versions_1.versions.gatling.jsAdapter) {
        log_1.logger.info(`Installing dependencies bundle for Gatling JS ${version}, which is the current version`);
    }
    else {
        log_1.logger.info(`Installing dependencies bundle for Gatling JS ${version}, which is not the current version (${versions_1.versions.gatling.jsAdapter})`);
    }
    const bundlePath = getBundlePath(options, version);
    if (await canReadPath(bundlePath)) {
        throw Error(`Directory ${bundlePath} already exists`);
    }
    await promises_1.default.mkdir(bundlePath, { recursive: true });
    await zip.extract(null, bundlePath);
    if (os_1.osType !== "Windows_NT") {
        const graalVmBinDir = node_path_1.default.join(bundlePath, "graalvm", "bin");
        const binFiles = await promises_1.default.readdir(graalVmBinDir);
        for (const binFile of binFiles) {
            await promises_1.default.chmod(node_path_1.default.join(graalVmBinDir, binFile), 0o744); // chmod +x
        }
    }
    log_1.logger.info(`Gatling JS dependencies bundle installed in ${bundlePath}`);
    return getResolvedBundle(bundlePath);
};
exports.installBundleFile = installBundleFile;
const resolveBundle = async (options) => {
    const bundlePath = getBundlePath(options, versions_1.versions.gatling.jsAdapter);
    if (await canReadPath(bundlePath)) {
        // Basic check of the installed bundle we found
        const bundleMetadataPath = node_path_1.default.join(bundlePath, metadataFileName);
        let version = "";
        try {
            const f = await promises_1.default.readFile(bundleMetadataPath, { encoding: "utf-8" });
            const metadata = JSON.parse(f);
            version = metadata.version;
        }
        catch { }
        if (version !== versions_1.versions.gatling.jsAdapter) {
            throw Error(`Inconsistent bundle content found at ${bundlePath}`);
        }
        return getResolvedBundle(bundlePath);
    }
    else {
        return await downloadAndInstallBundle(options);
    }
};
exports.resolveBundle = resolveBundle;
const getBundlePath = (options, version) => node_path_1.default.join(options.gatlingHome, "gatling-js-bundle", version);
const metadataFileName = "gatling-bundle.json";
const canReadPath = async (path) => {
    try {
        await promises_1.default.access(path, promises_1.default.constants.R_OK);
        return true;
    }
    catch (e) {
        if (e.code === "ENOENT") {
            return false;
        }
        else {
            throw e;
        }
    }
};
const getResolvedBundle = (bundlePath) => ({
    graalvmHome: node_path_1.default.join(bundlePath, "graalvm"),
    jvmClasspath: node_path_1.default.join(bundlePath, "lib", "java", "*")
});
const downloadAndInstallBundle = async (options) => {
    const tmpFolder = node_path_1.default.join(options.gatlingHome, "tmp");
    if (!fsSync.existsSync(tmpFolder)) {
        await promises_1.default.mkdir(tmpFolder, { recursive: true });
    }
    const tmpFile = node_path_1.default.join(tmpFolder, "bundle-download.zip");
    if (fsSync.existsSync(tmpFile)) {
        await promises_1.default.rm(tmpFile);
    }
    const version = versions_1.versions.gatling.jsAdapter;
    const url = `https://github.com/gatling/gatling-js/releases/download/v${version}/gatling-js-bundle-${version}-${os_1.osType}-${os_1.osArch}.zip`;
    try {
        log_1.logger.info(`Downloading bundle file from ${url} to temporary file ${tmpFile}`);
        await (0, download_1.downloadFile)(url, tmpFile);
        const resolvedBundle = await (0, exports.installBundleFile)({ ...options, bundleFilePath: tmpFile });
        log_1.logger.info(`Deleting temporary file ${tmpFile}`);
        await promises_1.default.rm(tmpFile);
        return resolvedBundle;
    }
    catch (e) {
        log_1.logger.error(`Failed to automatically download and install the Gatling dependency bundle. You can try to:
1. Make sure you have access to https://github.com/gatling/gatling-js/releases/; and if you connect to the Internet through a proxy, make sure it is configured in your NPM configuration file (.npmrc).
2. Alternatively, you can try manually downloading the file from ${url}, and install it with the command 'npx gatling install <path-to-downloaded-file.zip>'.`);
        throw e;
    }
};
